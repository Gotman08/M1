// ============================================================================
// Solveur Éléments Finis P1 - Exercice 3 (Méthode Standard)
// ============================================================================
// Problème :
//   -Δu = f    dans Ω = ]0,4[ × ]0,2[
//   u = uE     sur Γ_D = {0,4} × [0,2]  (label 1)
//   ∇u·n = 0   sur Γ_N = ]0,4[ × {0,2}  (label 2)
//
// Solution exacte : u(x,y) = 1 + sin(πx/2) + x(x-4)cos(πy/2)
// ============================================================================

// Fonction pour lire le nom du maillage depuis la ligne de commande
string meshfile = "meshes/m1.msh";
if (ARGV.n >= 2) {
    meshfile = ARGV[1];
}

// Chargement du maillage
mesh Th = readmesh(meshfile);
cout << "\n========================================" << endl;
cout << "Maillage chargé : " << meshfile << endl;
cout << "  Sommets   : " << Th.nv << endl;
cout << "  Triangles : " << Th.nt << endl;
cout << "========================================\n" << endl;

// ============================================================================
// EXERCICE 1 : Définition des fonctions exactes
// ============================================================================

// Solution exacte
func real uExact(real x, real y) {
    return 1.0 + sin(pi*x/2.0) + x*(x-4.0)*cos(pi*y/2.0);
}

// Gradient de la solution exacte
// ∂u/∂x = (π/2)cos(πx/2) + (2x-4)cos(πy/2)
func real duExactDx(real x, real y) {
    return (pi/2.0)*cos(pi*x/2.0) + (2.0*x - 4.0)*cos(pi*y/2.0);
}

// ∂u/∂y = -(π/2)x(x-4)sin(πy/2)
func real duExactDy(real x, real y) {
    return -(pi/2.0)*x*(x-4.0)*sin(pi*y/2.0);
}

// Second membre f = -Δu
// f = (π²/4)[sin(πx/2) + x(x-4)cos(πy/2)] - 2cos(πy/2)
func real f(real x, real y) {
    real pi2_4 = pi*pi / 4.0;
    return pi2_4 * (sin(pi*x/2.0) + x*(x-4.0)*cos(pi*y/2.0)) - 2.0*cos(pi*y/2.0);
}

// Condition de Dirichlet
func real uD(real x, real y) {
    return uExact(x, y);
}

// ============================================================================
// FORMULATION VARIATIONNELLE
// ============================================================================

// Espace d'éléments finis P1
fespace Vh(Th, P1);

// Inconnue et fonction test
Vh uh, vh;

// Problème variationnel :
// ∫_Ω ∇u·∇v = ∫_Ω f·v  pour tout v ∈ V_0
// avec u = uE sur Γ_D
problem Poisson(uh, vh) =
    // Forme bilinéaire a(u,v) = ∫_Ω ∇u·∇v
    int2d(Th)(dx(uh)*dx(vh) + dy(uh)*dy(vh))

    // Forme linéaire L(v) = ∫_Ω f·v
    - int2d(Th)(f(x,y) * vh)

    // Condition de Dirichlet (imposée fortement sur label 1)
    + on(1, uh = uD(x,y));

    // Note : La condition de Neumann homogène ∇u·n = 0 est naturelle,
    // elle n'apparaît pas dans la formulation variationnelle

// Résolution du système linéaire
cout << "Résolution du système linéaire..." << endl;
Poisson;
cout << "✓ Système résolu\n" << endl;

// ============================================================================
// CALCUL DE L'ERREUR EN SEMI-NORME H¹
// ============================================================================

// Interpolation de la solution exacte
Vh uEx;
uEx = uExact(x, y);

// Interpolation du gradient exact
Vh duExDx, duExDy;
duExDx = duExactDx(x, y);
duExDy = duExactDy(x, y);

// Calcul de l'erreur en semi-norme H¹(Ω)
// |u - uh|_{H¹} = sqrt(∫_Ω |∇(u - uh)|² dx)
real errH1 = sqrt(
    int2d(Th)(
        (dx(uEx) - dx(uh))^2 + (dy(uEx) - dy(uh))^2
    )
);

// Calcul de l'erreur L²
real errL2 = sqrt(
    int2d(Th)(
        (uEx - uh)^2
    )
);

// Calcul de la norme H¹ de la solution exacte (pour référence)
real normH1 = sqrt(
    int2d(Th)(
        dx(uEx)^2 + dy(uEx)^2
    )
);

// ============================================================================
// AFFICHAGE DES RÉSULTATS
// ============================================================================

cout << "========================================" << endl;
cout << "RÉSULTATS DE LA VALIDATION" << endl;
cout << "========================================" << endl;
cout << "Erreur L²          : " << errL2 << endl;
cout << "Erreur H¹          : " << errH1 << endl;
cout << "Norme H¹ exacte    : " << normH1 << endl;
cout << "Erreur relative H¹ : " << (errH1/normH1)*100 << " %" << endl;
cout << "========================================\n" << endl;

// Sauvegarde de l'erreur avec 16 décimales
{
    ofstream resultsFile("results/" + meshfile(8:10) + "_error.txt");
    resultsFile.precision(16);
    resultsFile.scientific;
    resultsFile << errH1 << endl;
}

cout << "✓ Erreur sauvegardée dans results/" << meshfile(8:10) << "_error.txt\n" << endl;

// ============================================================================
// VISUALISATION (optionnel)
// ============================================================================

// Décommenter pour visualiser les résultats
// plot(uh, value=true, fill=true, cmm="Solution numérique uh");
// plot(uEx, value=true, fill=true, cmm="Solution exacte u");
// plot(uEx - uh, value=true, fill=true, cmm="Erreur u - uh");
