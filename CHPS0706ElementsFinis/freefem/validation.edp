// Solveur Éléments Finis P1 - Exercice 3 (Méthode Standard)
// Problème :
//   -Deltau = f    dans Omega = ]0,4[ x ]0,2[
//   u = uE     sur Gamma_D = {0,4} x [0,2]  (labels 2,4)
//   grad(u).n = 0   sur Gamma_N = ]0,4[ x {0,2}  (labels 1,3)
//
// Solution exacte : u(x,y) = 1 + sin(pi*x/2) + x(x-4)cos(pi*y/2)

// Lecture du nom du maillage depuis la ligne de commande
string meshfile = "meshes/m1.msh";
if (ARGV.n >= 3) {
    meshfile = ARGV[2];
}

// Chargement du maillage
mesh Th = readmesh(meshfile);
cout << "\n========================================" << endl;
cout << "Maillage charge : " << meshfile << endl;
cout << "  Sommets   : " << Th.nv << endl;
cout << "  Triangles : " << Th.nt << endl;
cout << "========================================\n" << endl;

// Définition des fonctions exactes

// Solution exacte u(x,y) = 1 + sin(pi*x/2) + x(x-4)cos(pi*y/2)
func real uExact(real x, real y) {
    return 1.0 + sin(pi*x/2.0) + x*(x-4.0)*cos(pi*y/2.0);
}

// Gradient de la solution exacte (calcul analytique)
// du/dx = (pi/2)cos(pi*x/2) + (2x-4)cos(pi*y/2)
func real duExactDx(real x, real y) {
    return (pi/2.0)*cos(pi*x/2.0) + (2.0*x - 4.0)*cos(pi*y/2.0);
}

// du/dy = -(pi/2)x(x-4)sin(pi*y/2)
func real duExactDy(real x, real y) {
    return -(pi/2.0)*x*(x-4.0)*sin(pi*y/2.0);
}

// Condition de Neumann : sur y=0 et y=2, sin(0)=0 et sin(pi)=0 donc du/dy = 0 (ok)

// Second membre f = -Delta(u)
// Calcul : d2u/dx2 = -(pi^2/4)sin(pi*x/2) + 2cos(pi*y/2)
//          d2u/dy2 = -(pi^2/4)x(x-4)cos(pi*y/2)
// Donc f = (pi^2/4)[sin(pi*x/2) + x(x-4)cos(pi*y/2)] - 2cos(pi*y/2)
func real f(real x, real y) {
    real pi24 = pi*pi / 4.0;
    return pi24 * (sin(pi*x/2.0) + x*(x-4.0)*cos(pi*y/2.0)) - 2.0*cos(pi*y/2.0);
}

// Condition de Dirichlet
func real uD(real x, real y) {
    return uExact(x, y);
}

// Formulation variationnelle

fespace Vh(Th, P1);
Vh uh, vh;

// Problème : trouver uh dans Vh tel que
// int_Omega grad(uh).grad(vh) = int_Omega f*vh  pour tout vh
// avec uh = uE sur Gamma_D
problem Poisson(uh, vh) =
    int2d(Th)(dx(uh)*dx(vh) + dy(uh)*dy(vh))  // forme bilinéaire
    - int2d(Th)(f(x,y) * vh)                  // forme linéaire
    + on(2, uh = uD(x,y))                     // Dirichlet sur label 2 (x=4)
    + on(4, uh = uD(x,y));                    // Dirichlet sur label 4 (x=0)

// Note : Neumann homogène est naturel, pas besoin de l'imposer

cout << "Resolution du systeme lineaire..." << endl;
Poisson;
cout << "Systeme resolu" << endl;

// Calcul des erreurs

Vh uEx;
uEx = uExact(x, y);

// Erreur H1 semi-norme
// Attention : utiliser les dérivées exactes duExactDx/Dy, pas dx(uEx) !
// (l'interpolation P1 change les gradients)
real errH1 = sqrt(
    int2d(Th)(
        (duExactDx(x,y) - dx(uh))^2 + (duExactDy(x,y) - dy(uh))^2
    )
);

// Erreur L2
real errL2 = sqrt(int2d(Th)((uEx - uh)^2));

// Norme H1 de la solution exacte
real normH1 = sqrt(int2d(Th)(duExactDx(x,y)^2 + duExactDy(x,y)^2));

// Affichage des résultats
cout << "========================================" << endl;
cout << "RESULTATS DE LA VALIDATION" << endl;
cout << "========================================" << endl;
cout << "Erreur L2          : " << errL2 << endl;
cout << "Erreur H1          : " << errH1 << endl;
cout << "Norme H1 exacte    : " << normH1 << endl;
cout << "Erreur relative H1 : " << (errH1/normH1)*100 << " %" << endl;
cout << "========================================\n" << endl;

// Sauvegarde de l'erreur (16 décimales pour convergence)
{
    ofstream resultsFile("results/" + meshfile(7:8) + "_error.txt");
    resultsFile.precision(16);
    resultsFile.scientific;
    resultsFile << errH1 << endl;
}

cout << "Erreur sauvegardee dans results/" + meshfile(7:8) + "_error.txt" << endl;

// Visualisation (optionnel, décommenter si besoin)
// plot(uh, value=true, fill=true, cmm="Solution numérique uh");
// plot(uEx, value=true, fill=true, cmm="Solution exacte u");
// plot(uEx - uh, value=true, fill=true, cmm="Erreur u - uh");
