// ============================================================================
// Solveur Éléments Finis P1 - Exercice 3 (Méthode de Pénalisation)
// ============================================================================
// Problème :
//   -Δu = f    dans Ω = ]0,4[ × ]0,2[
//   u = uE     sur Γ_D = {0,4} × [0,2]  (label 1) - TRAITÉ PAR PÉNALISATION
//   ∇u·n = 0   sur Γ_N = ]0,4[ × {0,2}  (label 2)
//
// Méthode de pénalisation :
//   La condition de Dirichlet u = uE est traitée comme une condition
//   de Fourier-Robin avec un grand paramètre α >> 1 :
//   α·u = α·uE  sur Γ_D
//
// Solution exacte : u(x,y) = 1 + sin(πx/2) + x(x-4)cos(πy/2)
// ============================================================================

// Fonction pour lire le nom du maillage depuis la ligne de commande
string meshfile = "meshes/m1.msh";
if (ARGV.n >= 2) {
    meshfile = ARGV[1];
}

// Chargement du maillage
mesh Th = readmesh(meshfile);
cout << "\n========================================" << endl;
cout << "Maillage charge : " << meshfile << endl;
cout << "  Sommets   : " << Th.nv << endl;
cout << "  Triangles : " << Th.nt << endl;
cout << "========================================\n" << endl;

// ============================================================================
// PARAMÈTRE DE PÉNALISATION
// ============================================================================

// Paramètre de pénalisation (très grand pour approcher la condition de Dirichlet)
// Typiquement : α = 10^10 ou plus
real alpha = 1e10;

cout << "Parametre de penalisation alpha = " << alpha << endl;
cout << "(Methode de Fourier-Robin pour imposer Dirichlet)\n" << endl;

// ============================================================================
// EXERCICE 1 : Définition des fonctions exactes
// ============================================================================

// Solution exacte
func real uExact(real x, real y) {
    return 1.0 + sin(pi*x/2.0) + x*(x-4.0)*cos(pi*y/2.0);
}

// Gradient de la solution exacte
func real duExactDx(real x, real y) {
    return (pi/2.0)*cos(pi*x/2.0) + (2.0*x - 4.0)*cos(pi*y/2.0);
}

func real duExactDy(real x, real y) {
    return -(pi/2.0)*x*(x-4.0)*sin(pi*y/2.0);
}

// Second membre f = -Δu
func real f(real x, real y) {
    real pi24 = pi*pi / 4.0;
    return pi24 * (sin(pi*x/2.0) + x*(x-4.0)*cos(pi*y/2.0)) - 2.0*cos(pi*y/2.0);
}

// Condition de Dirichlet (maintenant traitée par pénalisation)
func real uD(real x, real y) {
    return uExact(x, y);
}

// ============================================================================
// FORMULATION VARIATIONNELLE AVEC PÉNALISATION
// ============================================================================

// Espace d'éléments finis P1
fespace Vh(Th, P1);

// Inconnue et fonction test
Vh uh, vh;

// Problème variationnel avec pénalisation :
// ∫_Ω ∇u·∇v + α∫_{Γ_D} u·v = ∫_Ω f·v + α∫_{Γ_D} uE·v
//
// Interprétation physique :
//   Le terme α∫_{Γ_D} (u - uE)·v impose faiblement u ≈ uE sur Γ_D
//   quand α → +∞
problem PoissonPenalized(uh, vh) =
    // Forme bilinéaire volumique : a(u,v) = ∫_Ω ∇u·∇v
    int2d(Th)(dx(uh)*dx(vh) + dy(uh)*dy(vh))

    // Terme de pénalisation sur Γ_D (label 1) : α∫_{Γ_D} u·v
    + int1d(Th, 1)(alpha * uh * vh)

    // Forme linéaire volumique : L(v) = ∫_Ω f·v
    - int2d(Th)(f(x,y) * vh)

    // Terme de pénalisation du second membre : α∫_{Γ_D} uE·v
    - int1d(Th, 1)(alpha * uD(x,y) * vh);

    // Note : Pas de condition "on" ici, tout est dans la formulation faible
    // La condition de Neumann ∇u·n = 0 reste naturelle (label 2)

// Résolution du système linéaire
cout << "Resolution du systeme lineaire avec penalisation..." << endl;
PoissonPenalized;
cout << "Systeme resolu" << endl;

// ============================================================================
// CALCUL DE L'ERREUR EN SEMI-NORME H¹
// ============================================================================

// Interpolation de la solution exacte
Vh uEx;
uEx = uExact(x, y);

// Interpolation du gradient exact
Vh duExDx, duExDy;
duExDx = duExactDx(x, y);
duExDy = duExactDy(x, y);

// Calcul de l'erreur en semi-norme H¹(Ω)
real errH1 = sqrt(
    int2d(Th)(
        (dx(uEx) - dx(uh))^2 + (dy(uEx) - dy(uh))^2
    )
);

// Calcul de l'erreur L²
real errL2 = sqrt(
    int2d(Th)(
        (uEx - uh)^2
    )
);

// Erreur L² sur le bord de Dirichlet (pour vérifier la pénalisation)
real errL2_boundary = sqrt(
    int1d(Th, 1)(
        (uEx - uh)^2
    )
);

// Calcul de la norme H¹ de la solution exacte
real normH1 = sqrt(
    int2d(Th)(
        dx(uEx)^2 + dy(uEx)^2
    )
);

// ============================================================================
// AFFICHAGE DES RÉSULTATS
// ============================================================================

cout << "========================================" << endl;
cout << "RESULTATS DE LA VALIDATION (PENALISATION)" << endl;
cout << "========================================" << endl;
cout << "Erreur L2          : " << errL2 << endl;
cout << "Erreur H1          : " << errH1 << endl;
cout << "Erreur L2 sur Gamma_D  : " << errL2_boundary << endl;
cout << "Norme H1 exacte    : " << normH1 << endl;
cout << "Erreur relative H1 : " << (errH1/normH1)*100 << " %" << endl;
cout << "========================================\n" << endl;

// Sauvegarde de l'erreur avec 16 décimales
{
    ofstream resultsFile("results/" + meshfile(8:10) + "_error_pen.txt");
    resultsFile.precision(16);
    resultsFile.scientific;
    resultsFile << errH1 << endl;
}

cout << "Erreur sauvegardee dans results/" << meshfile(8:10) << "_error_pen.txt" << endl;

// ============================================================================
// VÉRIFICATION DE LA QUALITÉ DE LA PÉNALISATION
// ============================================================================

cout << "Verification de la penalisation :" << endl;
cout << "  Si alpha est suffisamment grand, l'erreur sur Gamma_D doit etre tres petite" << endl;
cout << "  Erreur L2 sur Gamma_D = " << errL2_boundary << endl;
if (errL2_boundary < 1e-6) {
    cout << "  Penalisation efficace (erreur < 10^-6)" << endl;
} else if (errL2_boundary < 1e-3) {
    cout << "  Penalisation acceptable (erreur < 10^-3)" << endl;
} else {
    cout << "  Attention : alpha peut-etre trop petit (erreur > 10^-3)" << endl;
}
cout << endl;

// ============================================================================
// VISUALISATION (optionnel)
// ============================================================================

// Décommenter pour visualiser les résultats
// plot(uh, value=true, fill=true, cmm="Solution numérique uh (pénalisée)");
// plot(uEx, value=true, fill=true, cmm="Solution exacte u");
// plot(uEx - uh, value=true, fill=true, cmm="Erreur u - uh");
